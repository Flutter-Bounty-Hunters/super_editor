import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:super_editor/super_editor.dart';
import 'package:super_text_layout/super_text_layout.dart';

/// Displays debug information related to text input.
///
/// Shows a list of events, which could be generated by the OS
/// or the editor.
class SuperEditorImeDebugger extends StatefulWidget {
  const SuperEditorImeDebugger({
    Key? key,
    required this.debugger,
    this.componentBuilders = defaultTextInputDebugComponentBuilders,
  }) : super(key: key);

  /// The object that collects and holds the debug events.
  final TextInputDebugger debugger;

  /// Priority list of widget factories that create the visual representation
  /// of the events.
  final List<TextInputDebugComponentBuilder> componentBuilders;

  @override
  State<SuperEditorImeDebugger> createState() => _SuperEditorImeDebuggerState();
}

class _SuperEditorImeDebuggerState extends State<SuperEditorImeDebugger> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    widget.debugger.addListener(_scrollToTheEndOnNextFrame);
    _scrollToTheEndOnNextFrame();
  }

  @override
  void didUpdateWidget(covariant SuperEditorImeDebugger oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.debugger != widget.debugger) {
      oldWidget.debugger.removeListener(_scrollToTheEndOnNextFrame);
      widget.debugger.addListener(_scrollToTheEndOnNextFrame);
      _scrollToTheEndOnNextFrame();
    }
  }

  @override
  void dispose() {
    widget.debugger.removeListener(_scrollToTheEndOnNextFrame);
    _scrollController.dispose();
    super.dispose();
  }

  void _scrollToTheEndOnNextFrame() {
    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
      if (!mounted) {
        return;
      }

      _scrollController.jumpTo(_scrollController.position.maxScrollExtent);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        children: [
          Expanded(
            child: ListenableBuilder(
              listenable: widget.debugger,
              builder: (context, child) {
                return ListView.separated(
                  controller: _scrollController,
                  itemCount: widget.debugger.events.length,
                  itemBuilder: (context, index) => _buildEvent(context, widget.debugger.events[index]),
                  separatorBuilder: (context, index) => SizedBox(height: 20),
                );
              },
            ),
          ),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: widget.debugger.clear,
              child: Text('Clear'),
            ),
          ),
        ],
      ),
    );
  }

  /// Builds the visual representation of the [event].
  ///
  /// Throws if there isn't a component builder for this event.
  Widget _buildEvent(BuildContext context, TextInputDebugEvent event) {
    Widget? content;
    for (final builder in widget.componentBuilders) {
      content = builder(context, event);
      if (content != null) {
        break;
      }
    }

    if (content == null) {
      throw Exception('No component for $event');
    }

    return content;
  }
}

typedef TextInputDebugComponentBuilder = Widget? Function(BuildContext context, TextInputDebugEvent event);

/// Component builders that generate a visual representation for the events.
const defaultTextInputDebugComponentBuilders = <TextInputDebugComponentBuilder>[
  _buildSetEditingStateEvent,
  _buildTextDeltaEvents,
  _buildKeyEvent,
  _buildGenericEvent,
];

/// Build the widget for a `setEditingState` call.
Widget? _buildSetEditingStateEvent(BuildContext context, TextInputDebugEvent event) {
  final textEditingValue = event.data;
  if (textEditingValue is! TextEditingValue) {
    return null;
  }

  return ListTile(
    leading: Icon(
      Icons.arrow_upward,
      color: Colors.green,
    ),
    title: Text(
      event.method,
      style: TextStyle(fontWeight: FontWeight.bold),
    ),
    subtitle: Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _createLabelAndValue(
          label: 'Text',
          text: textEditingValue.text,
          selection: textEditingValue.selection,
        ),
        SizedBox(height: 5),
        _createLabelAndValue(
          label: 'Selection',
          text: textEditingValue.selection.toString(),
        ),
        SizedBox(height: 5),
        _createLabelAndValue(
          label: 'Composing region',
          text: textEditingValue.composing.toString(),
        ),
      ],
    ),
  );
}

/// Build the widget for an `updateEditingStateWithDeltas` call.
Widget? _buildTextDeltaEvents(BuildContext context, TextInputDebugEvent event) {
  final params = event.data;
  if (params is! List<TextEditingDelta>) {
    return null;
  }

  final deltaComponents = params.map(
    (delta) {
      if (delta is TextEditingDeltaInsertion) {
        return _buildInsertionDeltaEvent(context, delta);
      }

      if (delta is TextEditingDeltaReplacement) {
        return _buildReplacementDeltaEvent(context, delta);
      }

      if (delta is TextEditingDeltaDeletion) {
        return _buildDeletionDeltaEvent(context, delta);
      }

      if (delta is TextEditingDeltaNonTextUpdate) {
        return _buildNonTextDeltaEvent(context, delta);
      }

      return SizedBox();
    },
  ).toList();
  return ListTile(
    leading: Icon(
      Icons.arrow_downward,
      color: Colors.blue,
    ),
    title: Text(
      event.method,
      style: TextStyle(fontWeight: FontWeight.bold),
    ),
    subtitle: Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ...deltaComponents,
      ],
    ),
  );
}

/// Build the widget for a `TextEditingDeltaInsertion`.
Widget _buildInsertionDeltaEvent(BuildContext context, TextEditingDeltaInsertion delta) {
  return Column(
    mainAxisSize: MainAxisSize.min,
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      _createLabelAndValue(
        label: 'Delta kind',
        text: delta.runtimeType.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Old Text',
        text: delta.oldText,
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Inserted Text',
        text: delta.textInserted,
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Insertion Offset',
        text: delta.insertionOffset.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'IME new text',
        text: delta.apply(TextEditingValue(text: delta.oldText)).text,
        attribution: _insertedTextAttribution,
        range: TextRange(
          start: delta.insertionOffset,
          end: delta.insertionOffset + delta.textInserted.length,
        ),
        selection: delta.selection,
      ),
      _createLabelAndValue(
        label: 'Selection',
        text: delta.selection.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Composing region',
        text: delta.composing.toString(),
      ),
    ],
  );
}

/// Build the widget for a `TextEditingDeltaReplacement`.
Widget _buildReplacementDeltaEvent(BuildContext context, TextEditingDeltaReplacement delta) {
  return Column(
    mainAxisSize: MainAxisSize.min,
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      _createLabelAndValue(
        label: 'Delta kind',
        text: delta.runtimeType.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Old Text',
        text: delta.oldText,
        attribution: _textRemovedAttribution,
        range: delta.replacedRange,
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Range',
        text: delta.replacedRange.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'IME new text',
        text: delta.apply(TextEditingValue(text: delta.oldText)).text,
        attribution: _insertedTextAttribution,
        range: TextRange(
          start: delta.replacedRange.start,
          end: delta.replacedRange.start + delta.replacementText.length,
        ),
        selection: delta.selection,
      ),
      _createLabelAndValue(
        label: 'Selection',
        text: delta.selection.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Composing region',
        text: delta.composing.toString(),
      ),
    ],
  );
}

/// Build the widget for a `TextEditingDeltaDeletion`.
Widget _buildDeletionDeltaEvent(BuildContext context, TextEditingDeltaDeletion delta) {
  return Column(
    mainAxisSize: MainAxisSize.min,
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      _createLabelAndValue(
        label: 'Delta kind',
        text: delta.runtimeType.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'OldText',
        text: delta.oldText,
        attribution: _textRemovedAttribution,
        range: delta.deletedRange,
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Range',
        text: delta.deletedRange.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'IME new text',
        text: delta.apply(TextEditingValue(text: delta.oldText)).text,
        selection: delta.selection,
      ),
      _createLabelAndValue(
        label: 'Selection',
        text: delta.selection.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Composing region',
        text: delta.composing.toString(),
      ),
    ],
  );
}

/// Build the widget for a `TextEditingDeltaNonTextUpdate`.
Widget _buildNonTextDeltaEvent(BuildContext context, TextEditingDeltaNonTextUpdate delta) {
  return Column(
    mainAxisSize: MainAxisSize.min,
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      _createLabelAndValue(
        label: 'Delta kind',
        text: delta.runtimeType.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'IME Text',
        text: delta.apply(TextEditingValue(text: delta.oldText)).text,
        selection: delta.selection,
      ),
      _createLabelAndValue(
        label: 'Selection',
        text: delta.selection.toString(),
      ),
      SizedBox(height: 5),
      _createLabelAndValue(
        label: 'Composing region',
        text: delta.composing.toString(),
      ),
    ],
  );
}

/// Build the widget for an `onKey` call.
Widget? _buildKeyEvent(BuildContext context, TextInputDebugEvent event) {
  final keyEvent = event.data;
  if (keyEvent is! RawKeyDownEvent) {
    return null;
  }

  return ListTile(
    leading: Icon(
      Icons.arrow_downward,
      color: Colors.blue,
    ),
    title: Text(
      event.method,
      style: TextStyle(fontWeight: FontWeight.bold),
    ),
    subtitle: Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _createLabelAndValue(
          label: 'Key',
          text: keyEvent.data.physicalKey.debugName ?? keyEvent.data.keyLabel,
        ),
      ],
    ),
  );
}

/// Build the widget for any given [event].
Widget _buildGenericEvent(BuildContext context, TextInputDebugEvent event) {
  return ListTile(
    leading: Icon(
      Icons.info,
      color: Colors.blue,
    ),
    title: Text(
      event.method,
      style: TextStyle(fontWeight: FontWeight.bold),
    ),
    subtitle: Text(event.data.toString()),
  );
}

/// Applies styles to highlight text insertions and deletions.
TextStyle _deltaTextStyler(Set<Attribution> attributions) {
  TextStyle newStyle = TextStyle(
    color: Colors.black,
    fontSize: 14,
  );

  if (attributions.contains(boldAttribution)) {
    newStyle = newStyle.copyWith(fontWeight: FontWeight.bold);
  }

  if (attributions.contains(_insertedTextAttribution)) {
    newStyle = newStyle.copyWith(
      decoration: TextDecoration.underline,
      color: Colors.blue,
      fontWeight: FontWeight.bold,
    );
  }

  if (attributions.contains(_textRemovedAttribution)) {
    newStyle = newStyle.copyWith(
      decoration: TextDecoration.underline,
      color: Colors.red,
      fontWeight: FontWeight.bold,
    );
  }

  return newStyle;
}

/// If [selection] is given, the selection
Widget _createLabelAndValue({
  required String label,
  required String text,
  Attribution? attribution,
  TextRange? range,
  TextSelection? selection,
}) {
  // Adjust the selection to account for the label.
  final transposedSelection = selection != null //
      ? selection.copyWith(
          baseOffset: selection.baseOffset + label.length + 2,
          extentOffset: selection.extentOffset + label.length + 2,
        )
      : null;

  final spans = AttributedSpans()
    ..addAttribution(
      newAttribution: boldAttribution,
      start: 0,
      end: label.length,
    );

  if (attribution != null && range != null) {
    spans.addAttribution(
      newAttribution: attribution,
      start: range.start + label.length + 2,
      end: range.end + label.length + 1,
    );
  }

  return SuperTextWithSelection.single(
    richText: AttributedText(
      text: '$label: $text',
      spans: spans,
    ).computeTextSpan(_deltaTextStyler),
    userSelection: selection != null //
        ? UserSelection(
            selection: transposedSelection!,
            blinkCaret: false,
          )
        : null,
  );
}

/// [Attribution] which marks a text range as inserted.
const _insertedTextAttribution = const NamedAttribution('textInsertedAttribution');

/// [Attribution] which marks a range as removed.
const _textRemovedAttribution = const NamedAttribution('textRemovedAttribution');
